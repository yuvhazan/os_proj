[1mdiff --git a/Makefile b/Makefile[m
[1mindex 328f9c6..b887123 100644[m
[1m--- a/Makefile[m
[1m+++ b/Makefile[m
[36m@@ -28,7 +28,8 @@[m [mOBJS = \[m
   $K/sysfile.o \[m
   $K/kernelvec.o \[m
   $K/plic.o \[m
[31m-  $K/virtio_disk.o[m
[32m+[m[32m  $K/virtio_disk.o	\[m
[32m+[m[32m  $K/cas.o	\[m
 [m
 # riscv64-unknown-elf- or riscv64-linux-gnu-[m
 # perhaps in /opt/riscv/bin[m
[36m@@ -48,6 +49,10 @@[m [mTOOLPREFIX := $(shell if riscv64-unknown-elf-objdump -i 2>&1 | grep 'elf64-big'[m
 	echo "***" 1>&2; exit 1; fi)[m
 endif[m
 [m
[32m+[m[32mifndef BLNCFLG[m
[32m+[m[32mBLNCFLG := OFF[m
[32m+[m[32mendif[m
[32m+[m
 QEMU = qemu-system-riscv64[m
 [m
 CC = $(TOOLPREFIX)gcc[m
[36m@@ -62,6 +67,8 @@[m [mCFLAGS += -mcmodel=medany[m
 CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax[m
 CFLAGS += -I.[m
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)[m
[32m+[m[32mCFLAGS += -D BLNCFLG=$(BLNCFLG)[m
[32m+[m[32mCFLAGS += -D numcpus=$(CPUS)[m
 [m
 # Disable PIE when possible (for Ubuntu 16.10 toolchain)[m
 ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)[m
[36m@@ -132,6 +139,7 @@[m [mUPROGS=\[m
 	$U/_grind\[m
 	$U/_wc\[m
 	$U/_zombie\[m
[32m+[m	[32m$U/_castest\[m
 [m
 fs.img: mkfs/mkfs README $(UPROGS)[m
 	mkfs/mkfs fs.img README $(UPROGS)[m
[36m@@ -153,7 +161,7 @@[m [mQEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \[m
 	then echo "-gdb tcp::$(GDBPORT)"; \[m
 	else echo "-s -p $(GDBPORT)"; fi)[m
 ifndef CPUS[m
[31m-CPUS := 3[m
[32m+[m[32mCPUS := 4[m
 endif[m
 [m
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic[m
[1mdiff --git a/kernel/defs.h b/kernel/defs.h[m
[1mindex 3564db4..045bb42 100644[m
[1m--- a/kernel/defs.h[m
[1m+++ b/kernel/defs.h[m
[36m@@ -104,6 +104,10 @@[m [mvoid            yield(void);[m
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);[m
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);[m
 void            procdump(void);[m
[32m+[m[32mint             set_cpu(int cpu_num);[m
[32m+[m[32mint             get_cpu();[m
[32m+[m[32mint             cpu_process_count(int cpu_num);[m
[32m+[m
 [m
 // swtch.S[m
 void            swtch(struct context*, struct context*);[m
[1mdiff --git a/kernel/param.h b/kernel/param.h[m
[1mindex b5fdcb2..36c1f3e 100644[m
[1m--- a/kernel/param.h[m
[1m+++ b/kernel/param.h[m
[36m@@ -11,3 +11,9 @@[m
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache[m
 #define FSSIZE       1000  // size of file system in blocks[m
 #define MAXPATH      128   // maximum file path name[m
[32m+[m
[32m+[m[32m#ifdef numcpus[m
[32m+[m[32m#define CPUS numcpus[m
[32m+[m[32m#else[m
[32m+[m[32m#define CPUS 1[m
[32m+[m[32m#endif[m
\ No newline at end of file[m
[1mdiff --git a/kernel/proc.c b/kernel/proc.c[m
[1mindex 22e7ce4..91ef2a7 100644[m
[1m--- a/kernel/proc.c[m
[1m+++ b/kernel/proc.c[m
[36m@@ -6,10 +6,279 @@[m
 #include "proc.h"[m
 #include "defs.h"[m
 [m
[31m-struct cpu cpus[NCPU];[m
[32m+[m[32mextern uint64 cas (volatile void* address, int expected, int newval);[m
[32m+[m
[32m+[m[32mstruct cpu cpus[CPUS];[m
[32m+[m
[32m+[m[32mstruct proc* remove_first(int type, int cpu_id);[m
[32m+[m
[32m+[m[32mstruct proc *zombie_list = 0;[m
[32m+[m[32mstruct proc *sleeping_list = 0;[m
[32m+[m[32mstruct proc *unused_list = 0;[m
[32m+[m
[32m+[m[32mstruct spinlock ready_lock[CPUS];[m
[32m+[m[32mstruct spinlock zombie_lock;[m
[32m+[m[32mstruct spinlock sleeping_lock;[m
[32m+[m[32mstruct spinlock unused_lock;[m
[32m+[m
[32m+[m[32mint init = 0;[m
[32m+[m[32mchar* init_name = "init\n";[m
[32m+[m
[32m+[m[32menum list_type {READYL, ZOMBIEL, SLEEPINGL, UNUSEDL};[m
[32m+[m
[32m+[m
[32m+[m[32mvoid[m
[32m+[m[32mincrease_size(int cpu_id){[m
[32m+[m[32m  struct cpu* c = &cpus[cpu_id];[m
[32m+[m[32m  uint64 old;[m
[32m+[m[32m  do{[m
[32m+[m[32m    old = c->queue_size;[m
[32m+[m[32m  } while(cas(&c->queue_size, old, old+1));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid[m
[32m+[m[32mdecrease_size(int cpu_id){[m
[32m+[m[32m  struct cpu* c = &cpus[cpu_id];[m
[32m+[m[32m  uint64 old;[m
[32m+[m[32m  do{[m
[32m+[m[32m    old = c->queue_size;[m
[32m+[m[32m  } while(cas(&c->queue_size, old, old-1));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32muint64[m
[32m+[m[32mget_queue_size(int cpu_id){[m
[32m+[m[32m  return cpus[cpu_id].queue_size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstruct proc*[m
[32m+[m[32msteal_process(){[m
[32m+[m[32m  struct proc* p=0;[m
[32m+[m[32m  for(int i=0; i<CPUS; i++){[m
[32m+[m[32m    if(get_queue_size(i)>1){[m
[32m+[m[32m      p = remove_first(READYL, i);[m
[32m+[m[32m      break;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  return p;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint[m
[32m+[m[32mget_lazy_cpu(){[m
[32m+[m[32m  int curr_min = 0;[m
[32m+[m[32m  for(int i=1; i<CPUS; i++){[m
[32m+[m[32m    curr_min = (cpus[i].queue_size < cpus[curr_min].queue_size) ? i : curr_min;[m
[32m+[m[32m  }[m
[32m+[m[32m  return curr_min;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32mstruct proc* get_head(int type, int cpu_id){[m
[32m+[m[32m  struct proc* p;[m
[32m+[m
[32m+[m[32m  switch (type)[m
[32m+[m[32m  {[m
[32m+[m[32m  case READYL:[m
[32m+[m[32m    p = cpus[cpu_id].head;[m
[32m+[m[32m    break;[m
[32m+[m[32m  case ZOMBIEL:[m
[32m+[m[32m    p = zombie_list;[m
[32m+[m[32m    break;[m
[32m+[m[32m  case SLEEPINGL:[m
[32m+[m[32m    p = sleeping_list;[m
[32m+[m[32m    break;[m
[32m+[m[32m  case UNUSEDL:[m
[32m+[m[32m    p = unused_list;[m
[32m+[m[32m    break;[m
[32m+[m[41m  [m
[32m+[m[32m  default:[m
[32m+[m[32m    panic("wrong type list");[m
[32m+[m[32m  }[m
[32m+[m[32m  return p;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid[m
[32m+[m[32mset_head(struct proc* p, int type, int cpu_id)[m
[32m+[m[32m{[m
[32m+[m[32m  switch (type)[m
[32m+[m[32m  {[m
[32m+[m[32m  case READYL:[m
[32m+[m[32m    cpus[cpu_id].head = p;[m
[32m+[m[32m    break;[m
[32m+[m[32m  case ZOMBIEL:[m
[32m+[m[32m    zombie_list = p;[m
[32m+[m[32m    break;[m
[32m+[m[32m  case SLEEPINGL:[m
[32m+[m[32m    sleeping_list = p;[m
[32m+[m[32m    break;[m
[32m+[m[32m  case UNUSEDL:[m
[32m+[m[32m    unused_list = p;[m
[32m+[m[32m    break;[m
[32m+[m
[32m+[m[41m  [m
[32m+[m[32m  default:[m
[32m+[m[32m    panic("wrong type list");[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid[m
[32m+[m[32macquire_list(int type, int cpu_id){[m
[32m+[m[32m  switch (type)[m
[32m+[m[32m  {[m
[32m+[m[32m  case READYL:[m
[32m+[m[32m    acquire(&ready_lock[cpu_id]);[m
[32m+[m[32m    break;[m
[32m+[m[32m  case ZOMBIEL:[m
[32m+[m[32m    acquire(&zombie_lock);[m
[32m+[m[32m    break;[m
[32m+[m[32m  case SLEEPINGL:[m
[32m+[m[32m    acquire(&sleeping_lock);[m
[32m+[m[32m    break;[m
[32m+[m[32m  case UNUSEDL:[m
[32m+[m[32m    acquire(&unused_lock);[m
[32m+[m[32m    break;[m
[32m+[m[41m  [m
[32m+[m[32m  default:[m
[32m+[m[32m    panic("wrong type list");[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid[m
[32m+[m[32mrelease_list(int type, int cpu_id){[m
[32m+[m[32m  switch (type)[m
[32m+[m[32m  {[m
[32m+[m[32m  case READYL:[m
[32m+[m[32m    release(&ready_lock[cpu_id]);[m
[32m+[m[32m    break;[m
[32m+[m[32m  case ZOMBIEL:[m
[32m+[m[32m    release(&zombie_lock);[m
[32m+[m[32m    break;[m
[32m+[m[32m  case SLEEPINGL:[m
[32m+[m[32m    release(&sleeping_lock);[m
[32m+[m[32m    break;[m
[32m+[m[32m  case UNUSEDL:[m
[32m+[m[32m    release(&unused_lock);[m
[32m+[m[32m    break;[m
[32m+[m[41m  [m
[32m+[m[32m  default:[m
[32m+[m[32m    panic("wrong type list");[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m
 [m
 struct proc proc[NPROC];[m
 [m
[32m+[m[32mvoid[m
[32m+[m[32madd_to_list(struct proc* p, struct proc* head, int type, int cpu_id)[m
[32m+[m[32m{[m
[32m+[m[32m  if(!p){[m
[32m+[m[32m    panic("can't add null to list");[m
[32m+[m[32m  }[m
[32m+[m[32m  // empty list[m
[32m+[m[32m  if(!head){[m
[32m+[m[32m      set_head(p, type, cpu_id);[m
[32m+[m[32m      release_list(type, cpu_id);[m
[32m+[m[32m  }[m
[32m+[m[32m  else{[m
[32m+[m[32m    struct proc* prev = 0;[m
[32m+[m[32m    while(head){[m
[32m+[m[32m      acquire(&head->list_lock);[m
[32m+[m
[32m+[m[32m      if(prev){[m
[32m+[m[32m        release(&prev->list_lock);[m
[32m+[m[32m      }[m
[32m+[m[32m      else{[m
[32m+[m[32m        release_list(type, cpu_id);[m
[32m+[m[32m      }[m
[32m+[m[32m      prev = head;[m
[32m+[m[32m      head = head->next;[m
[32m+[m[32m    }[m
[32m+[m[32m    prev->next = p;[m
[32m+[m[32m    release(&prev->list_lock);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid[m[41m [m
[32m+[m[32madd_proc_to_list(struct proc* p, int type, int cpu_id)[m
[32m+[m[32m{[m
[32m+[m[32m  // bad argument[m
[32m+[m[32m  if(!p){[m
[32m+[m[32m    panic("Add proc to list");[m
[32m+[m[32m  }[m
[32m+[m[32m  struct proc* head;[m
[32m+[m[32m  acquire_list(type, cpu_id);[m
[32m+[m[32m  head = get_head(type, cpu_id);[m
[32m+[m[32m  add_to_list(p, head, type, cpu_id);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstruct proc*[m[41m [m
[32m+[m[32mremove_first(int type, int cpu_id)[m
[32m+[m[32m{[m
[32m+[m[32m  acquire_list(type, cpu_id);[m
[32m+[m[32m  struct proc* head = get_head(type, cpu_id);[m
[32m+[m[32m  if(!head){[m
[32m+[m[32m    release_list(type, cpu_id);[m
[32m+[m[32m  }[m
[32m+[m[32m  else{[m
[32m+[m[32m    acquire(&head->list_lock);[m
[32m+[m
[32m+[m[32m    set_head(head->next, type, cpu_id);[m
[32m+[m[32m    head->next = 0;[m
[32m+[m[32m    release(&head->list_lock);[m
[32m+[m
[32m+[m[32m    release_list(type, cpu_id);[m
[32m+[m
[32m+[m[32m  }[m
[32m+[m[32m  return head;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint[m
[32m+[m[32mremove_proc(struct proc* p, int type){[m
[32m+[m[32m  acquire_list(type, p->cpu_id);[m
[32m+[m[32m  struct proc* head = get_head(type, p->cpu_id);[m
[32m+[m[32m  if(!head){[m
[32m+[m[32m    release_list(type, p->cpu_id);[m
[32m+[m[32m    return 0;[m
[32m+[m[32m  }[m
[32m+[m[32m  else{[m
[32m+[m[32m    struct proc* prev = 0;[m
[32m+[m[32m    if(p == head){[m
[32m+[m[32m      // remove node, p is the first link[m
[32m+[m[32m      acquire(&p->list_lock);[m
[32m+[m[32m      set_head(p->next, type, p->cpu_id);[m
[32m+[m[32m      p->next = 0;[m
[32m+[m[32m      release(&p->list_lock);[m
[32m+[m[32m      release_list(type, p->cpu_id);[m
[32m+[m[32m    }[m
[32m+[m[32m    else{[m
[32m+[m[32m      while(head){[m
[32m+[m[32m        acquire(&head->list_lock);[m
[32m+[m
[32m+[m[32m        if(p == head){[m
[32m+[m[32m          // remove node, head is the first link[m
[32m+[m[32m          prev->next = head->next;[m
[32m+[m[32m          p->next = 0;[m
[32m+[m[32m          release(&head->list_lock);[m
[32m+[m[32m          release(&prev->list_lock);[m
[32m+[m[32m          return 1;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if(!prev)[m
[32m+[m[32m          release_list(type,p->cpu_id);[m
[32m+[m[32m        else{[m
[32m+[m[32m          release(&prev->list_lock);[m
[32m+[m[32m        }[m
[32m+[m[41m          [m
[32m+[m[41m        [m
[32m+[m[32m        prev = head;[m
[32m+[m[32m        head = head->next;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m    return 0;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
 struct proc *initproc;[m
 [m
 int nextpid = 1;[m
[36m@@ -46,13 +315,28 @@[m [mproc_mapstacks(pagetable_t kpgtbl) {[m
 void[m
 procinit(void)[m
 {[m
[32m+[m[32m  if(CPUS > NCPU){[m
[32m+[m[32m    panic("recieved more CPUS than what is allowed");[m
[32m+[m[32m  }[m
   struct proc *p;[m
   [m
   initlock(&pid_lock, "nextpid");[m
   initlock(&wait_lock, "wait_lock");[m
[32m+[m[32m  initlock(&zombie_lock, "zombie lock");[m
[32m+[m[32m  initlock(&sleeping_lock, "sleeping lock");[m
[32m+[m[32m  initlock(&unused_lock, "unused lock");[m
[32m+[m[41m  [m
[32m+[m[32m  struct spinlock* s;[m
[32m+[m[32m  for(s = ready_lock; s <&ready_lock[CPUS]; s++){[m
[32m+[m[32m    initlock(s, "ready lock");[m
[32m+[m[32m  }[m
[32m+[m
   for(p = proc; p < &proc[NPROC]; p++) {[m
       initlock(&p->lock, "proc");[m
[32m+[m[32m      initlock(&p->list_lock, "list lock");[m
[32m+[m[32m      p->cpu_id = -1;[m
       p->kstack = KSTACK((int) (p - proc));[m
[32m+[m[32m      add_proc_to_list(p, UNUSEDL, -1);[m
   }[m
 }[m
 [m
[36m@@ -88,11 +372,11 @@[m [mmyproc(void) {[m
 int[m
 allocpid() {[m
   int pid;[m
[31m-  [m
[31m-  acquire(&pid_lock);[m
[31m-  pid = nextpid;[m
[31m-  nextpid = nextpid + 1;[m
[31m-  release(&pid_lock);[m
[32m+[m
[32m+[m[32m  do[m
[32m+[m[32m  {[m
[32m+[m[32m    pid = nextpid;[m
[32m+[m[32m  } while (cas(&nextpid, pid, pid+1));[m
 [m
   return pid;[m
 }[m
[36m@@ -105,20 +389,18 @@[m [mstatic struct proc*[m
 allocproc(void)[m
 {[m
   struct proc *p;[m
[31m-[m
[31m-  for(p = proc; p < &proc[NPROC]; p++) {[m
[31m-    acquire(&p->lock);[m
[31m-    if(p->state == UNUSED) {[m
[31m-      goto found;[m
[31m-    } else {[m
[31m-      release(&p->lock);[m
[31m-    }[m
[32m+[m[32m  p = remove_first(UNUSEDL, -1);[m
[32m+[m[32m  if(!p){[m
[32m+[m[32m    return 0;[m
   }[m
[32m+[m[32m  acquire(&p->lock);[m
[32m+[m[32m  goto found;[m
   return 0;[m
 [m
 found:[m
   p->pid = allocpid();[m
   p->state = USED;[m
[32m+[m[32m  p->next = 0;[m
 [m
   // Allocate a trapframe page.[m
   if((p->trapframe = (struct trapframe *)kalloc()) == 0){[m
[36m@@ -164,6 +446,8 @@[m [mfreeproc(struct proc *p)[m
   p->killed = 0;[m
   p->xstate = 0;[m
   p->state = UNUSED;[m
[32m+[m[32m  remove_proc(p, ZOMBIEL);[m
[32m+[m[32m  add_proc_to_list(p, UNUSEDL, -1);[m
 }[m
 [m
 // Create a user page table for a given process,[m
[36m@@ -225,6 +509,15 @@[m [muchar initcode[] = {[m
 void[m
 userinit(void)[m
 {[m
[32m+[m[32m  if(!init){[m
[32m+[m[32m    struct cpu* c;[m
[32m+[m[32m    for(c = cpus; c < &cpus[CPUS]; c++){[m
[32m+[m[32m      c->head = 0;[m
[32m+[m[32m      c->queue_size = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m    init = 1;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
   struct proc *p;[m
 [m
   p = allocproc();[m
[36m@@ -243,6 +536,10 @@[m [muserinit(void)[m
   p->cwd = namei("/");[m
 [m
   p->state = RUNNABLE;[m
[32m+[m[32m  p->cpu_id = 0;[m
[32m+[m[32m  increase_size(p->cpu_id);[m
[32m+[m
[32m+[m[32m  cpus[p->cpu_id].head = p;[m
 [m
   release(&p->lock);[m
 }[m
[36m@@ -275,7 +572,6 @@[m [mfork(void)[m
   int i, pid;[m
   struct proc *np;[m
   struct proc *p = myproc();[m
[31m-[m
   // Allocate process.[m
   if((np = allocproc()) == 0){[m
     return -1;[m
[36m@@ -313,8 +609,14 @@[m [mfork(void)[m
 [m
   acquire(&np->lock);[m
   np->state = RUNNABLE;[m
[32m+[m[41m  [m
[32m+[m[32m  int cpu_id = (BLNCFLG) ? get_lazy_cpu() : p->cpu_id;[m
[32m+[m[32m  np->cpu_id = cpu_id;[m
[32m+[m[32m  increase_size(cpu_id);[m
[32m+[m[32m  add_proc_to_list(np, READYL, cpu_id);[m
   release(&np->lock);[m
 [m
[32m+[m
   return pid;[m
 }[m
 [m
[36m@@ -370,6 +672,9 @@[m [mexit(int status)[m
 [m
   p->xstate = status;[m
   p->state = ZOMBIE;[m
[32m+[m[41m  [m
[32m+[m[32m  decrease_size(p->cpu_id);[m
[32m+[m[32m  add_proc_to_list(p, ZOMBIEL, -1);[m
 [m
   release(&wait_lock);[m
 [m
[36m@@ -386,7 +691,7 @@[m [mwait(uint64 addr)[m
   struct proc *np;[m
   int havekids, pid;[m
   struct proc *p = myproc();[m
[31m-[m
[32m+[m[41m  [m
   acquire(&wait_lock);[m
 [m
   for(;;){[m
[36m@@ -439,28 +744,39 @@[m [mscheduler(void)[m
 {[m
   struct proc *p;[m
   struct cpu *c = mycpu();[m
[32m+[m[32m  int cpu_id = cpuid();[m
   [m
   c->proc = 0;[m
   for(;;){[m
     // Avoid deadlock by ensuring that devices can interrupt.[m
     intr_on();[m
[32m+[m[32m    p = remove_first(READYL, cpu_id);[m
 [m
[31m-    for(p = proc; p < &proc[NPROC]; p++) {[m
[31m-      acquire(&p->lock);[m
[31m-      if(p->state == RUNNABLE) {[m
[31m-        // Switch to chosen process.  It is the process's job[m
[31m-        // to release its lock and then reacquire it[m
[31m-        // before jumping back to us.[m
[31m-        p->state = RUNNING;[m
[31m-        c->proc = p;[m
[31m-        swtch(&c->context, &p->context);[m
[31m-[m
[31m-        // Process is done running for now.[m
[31m-        // It should have changed its p->state before coming back.[m
[31m-        c->proc = 0;[m
[32m+[m[32m    //if empty list[m
[32m+[m[32m    if(!p){[m
[32m+[m[32m      if(!BLNCFLG){[m
[32m+[m[32m        continue;[m
       }[m
[31m-      release(&p->lock);[m
[32m+[m[32m      p = steal_process();[m
[32m+[m[32m      if(!p){[m[41m [m
[32m+[m[32m        continue;[m
[32m+[m[32m      }[m
[32m+[m[32m      decrease_size(p->cpu_id);[m
[32m+[m[32m      p->cpu_id = cpu_id;[m
[32m+[m[32m      increase_size(cpu_id);[m
     }[m
[32m+[m[32m    acquire(&p->lock);[m
[32m+[m
[32m+[m[32m    if(p->state!=RUNNABLE)[m
[32m+[m[32m      panic("bad proc was selected");[m
[32m+[m[41m  [m
[32m+[m[32m    p->state = RUNNING;[m
[32m+[m[32m    c->proc = p;[m
[32m+[m[41m    [m
[32m+[m[32m    swtch(&c->context, &p->context);[m
[32m+[m[41m  [m
[32m+[m[32m    c->proc = 0;[m
[32m+[m[32m    release(&p->lock);[m
   }[m
 }[m
 [m
[36m@@ -498,6 +814,7 @@[m [myield(void)[m
   struct proc *p = myproc();[m
   acquire(&p->lock);[m
   p->state = RUNNABLE;[m
[32m+[m[32m  add_proc_to_list(p, READYL, p->cpu_id);[m
   sched();[m
   release(&p->lock);[m
 }[m
[36m@@ -529,7 +846,6 @@[m [mvoid[m
 sleep(void *chan, struct spinlock *lk)[m
 {[m
   struct proc *p = myproc();[m
[31m-  [m
   // Must acquire p->lock in order to[m
   // change p->state and then call sched.[m
   // Once we hold p->lock, we can be[m
[36m@@ -543,6 +859,8 @@[m [msleep(void *chan, struct spinlock *lk)[m
   // Go to sleep.[m
   p->chan = chan;[m
   p->state = SLEEPING;[m
[32m+[m[32m  decrease_size(p->cpu_id);[m
[32m+[m[32m  add_proc_to_list(p, SLEEPINGL,-1);[m
 [m
   sched();[m
 [m
[36m@@ -554,22 +872,94 @@[m [msleep(void *chan, struct spinlock *lk)[m
   acquire(lk);[m
 }[m
 [m
[32m+[m[32m// void[m
[32m+[m[32m// wakeup(void *chan)[m
[32m+[m[32m// {[m
[32m+[m[32m//   struct proc *p;[m
[32m+[m
[32m+[m[32m//   for(p = proc; p < &proc[NPROC]; p++) {[m
[32m+[m[32m//     if(p != myproc()){[m
[32m+[m[32m//       acquire(&p->lock);[m
[32m+[m[32m//       if(p->state == SLEEPING && p->chan == chan) {[m
[32m+[m[32m//         p->state = RUNNABLE;[m
[32m+[m[32m//         remove_proc(p, SLEEPINGL);[m
[32m+[m[32m//         int cpu_id = (BLNCFLG) ? get_lazy_cpu() : p->cpu_id;[m
[32m+[m[32m//         add_proc_to_list(p, READYL, cpu_id);[m
[32m+[m[32m//         increase_size(cpu_id);[m
[32m+[m[32m//       }[m
[32m+[m[32m//       release(&p->lock);[m
[32m+[m[32m//     }[m
[32m+[m[32m//   }[m
[32m+[m[32m// }[m
[32m+[m
[32m+[m
[32m+[m
 // Wake up all processes sleeping on chan.[m
 // Must be called without any p->lock.[m
 void[m
 wakeup(void *chan)[m
 {[m
[32m+[m[32m  int released_list = 0;[m
   struct proc *p;[m
[31m-[m
[31m-  for(p = proc; p < &proc[NPROC]; p++) {[m
[31m-    if(p != myproc()){[m
[31m-      acquire(&p->lock);[m
[31m-      if(p->state == SLEEPING && p->chan == chan) {[m
[32m+[m[32m  struct proc* prev = 0;[m
[32m+[m[32m  struct proc* tmp;[m
[32m+[m[32m  acquire_list(SLEEPINGL, -1);[m
[32m+[m[32m  p = get_head(SLEEPINGL, -1);[m
[32m+[m[32m  while(p){[m
[32m+[m[32m    acquire(&p->lock);[m
[32m+[m[32m    acquire(&p->list_lock);[m
[32m+[m[32m    if(p->chan == chan){[m
[32m+[m[32m      if(p == get_head(SLEEPINGL, -1)){[m
[32m+[m[32m        //remove fom sleep[m
[32m+[m[32m        set_head(p->next, SLEEPINGL, -1);[m
[32m+[m[41m        [m
[32m+[m[32m        tmp = p;[m
[32m+[m[32m        p = p->next;[m
[32m+[m[32m        tmp->next = 0;[m
[32m+[m
[32m+[m[32m        //add to runnable[m
[32m+[m[32m        tmp->state = RUNNABLE;[m
[32m+[m[32m        int cpu_id = (BLNCFLG) ? get_lazy_cpu() : tmp->cpu_id;[m
[32m+[m[32m        tmp->cpu_id = cpu_id;[m
[32m+[m[32m        increase_size(cpu_id);[m
[32m+[m[32m        add_proc_to_list(tmp, READYL, cpu_id);[m
[32m+[m[32m        release(&tmp->list_lock);[m
[32m+[m[32m        release(&tmp->lock);[m
[32m+[m[32m      }[m
[32m+[m[32m      //we are not on the beginning of the list.[m
[32m+[m[32m      else{[m
[32m+[m[32m        prev->next = p->next;[m
[32m+[m[32m        p->next = 0;[m
         p->state = RUNNABLE;[m
[32m+[m[32m        int cpu_id = (BLNCFLG) ? get_lazy_cpu() : p->cpu_id;[m
[32m+[m[32m        p->cpu_id = cpu_id;[m
[32m+[m[32m        increase_size(cpu_id);[m
[32m+[m[32m        add_proc_to_list(p, READYL, cpu_id);[m
[32m+[m[32m        release(&p->list_lock);[m
[32m+[m[32m        release(&p->lock);[m
[32m+[m[32m        p = prev->next;[m
       }[m
[31m-      release(&p->lock);[m
[32m+[m[32m    }[m[41m [m
[32m+[m[32m    else{[m
[32m+[m[32m      //we are not on the chan[m
[32m+[m[32m      if(p == get_head(SLEEPINGL, -1)){[m
[32m+[m[32m        release_list(SLEEPINGL,-1);[m
[32m+[m[32m        released_list = 1;[m
[32m+[m[32m      }[m
[32m+[m[32m      else{[m
[32m+[m[32m        release(&prev->list_lock);[m
[32m+[m[32m      }[m
[32m+[m[32m      release(&p->lock);  //because we dont need to change his fields[m
[32m+[m[32m      prev = p;[m
[32m+[m[32m      p = p->next;[m
     }[m
   }[m
[32m+[m[32m  if(!released_list){[m
[32m+[m[32m    release_list(SLEEPINGL, -1);[m
[32m+[m[32m  }[m
[32m+[m[32m  if(prev){[m
[32m+[m[32m    release(&prev->list_lock);[m
[32m+[m[32m  }[m
 }[m
 [m
 // Kill the process with the given pid.[m
[36m@@ -587,6 +977,9 @@[m [mkill(int pid)[m
       if(p->state == SLEEPING){[m
         // Wake process from sleep().[m
         p->state = RUNNABLE;[m
[32m+[m[32m        remove_proc(p, SLEEPINGL);[m
[32m+[m[32m        add_proc_to_list(p, READYL, p->cpu_id);[m
[32m+[m[32m        increase_size(p->cpu_id);[m
       }[m
       release(&p->lock);[m
       return 0;[m
[36m@@ -654,3 +1047,28 @@[m [mprocdump(void)[m
     printf("\n");[m
   }[m
 }[m
[32m+[m
[32m+[m[32mint[m[41m [m
[32m+[m[32mset_cpu(int cpu_num)[m
[32m+[m[32m{[m
[32m+[m[32m  if(cpu_num<0 || cpu_num>NCPU){[m
[32m+[m[32m    return -1;[m
[32m+[m[32m  }[m
[32m+[m[32m  decrease_size(myproc()->cpu_id);[m
[32m+[m[32m  myproc()->cpu_id = cpu_num;[m
[32m+[m[32m  increase_size(cpu_num);[m
[32m+[m[32m  yield();[m
[32m+[m[32m  return cpu_num;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint[m[41m [m
[32m+[m[32mget_cpu()[m
[32m+[m[32m{[m
[32m+[m[32m  return myproc()->cpu_id;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint[m
[32m+[m[32mcpu_process_count(int cpu_num){[m
[32m+[m[32m  return get_queue_size(cpu_num);[m
[32m+[m[32m}[m
[41m+[m
[1mdiff --git a/kernel/proc.h b/kernel/proc.h[m
[1mindex f6ca8b7..81450db 100644[m
[1m--- a/kernel/proc.h[m
[1m+++ b/kernel/proc.h[m
[36m@@ -1,3 +1,10 @@[m
[32m+[m[32m#define OFF 0[m
[32m+[m[32m#define ON 1[m
[32m+[m
[32m+[m[32m#ifndef BLNCFLG[m
[32m+[m[32m#define BLNCFLG OFF[m
[32m+[m[32m#endif[m
[32m+[m
 // Saved registers for kernel context switches.[m
 struct context {[m
   uint64 ra;[m
[36m@@ -24,9 +31,11 @@[m [mstruct cpu {[m
   struct context context;     // swtch() here to enter scheduler().[m
   int noff;                   // Depth of push_off() nesting.[m
   int intena;                 // Were interrupts enabled before push_off()?[m
[32m+[m[32m  struct proc* head;[m
[32m+[m[32m  uint64 queue_size;[m
 };[m
 [m
[31m-extern struct cpu cpus[NCPU];[m
[32m+[m[32mextern struct cpu cpus[CPUS];[m
 [m
 // per-process data for the trap handling code in trampoline.S.[m
 // sits in a page by itself just under the trampoline page in the[m
[36m@@ -85,6 +94,7 @@[m [menum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };[m
 // Per-process state[m
 struct proc {[m
   struct spinlock lock;[m
[32m+[m[32m  struct spinlock list_lock;[m
 [m
   // p->lock must be held when using these:[m
   enum procstate state;        // Process state[m
[36m@@ -92,6 +102,8 @@[m [mstruct proc {[m
   int killed;                  // If non-zero, have been killed[m
   int xstate;                  // Exit status to be returned to parent's wait[m
   int pid;                     // Process ID[m
[32m+[m[32m  struct proc* next;           // next process indice in the list.[m
[32m+[m[32m  int cpu_id;                  // cpu to run on[m
 [m
   // wait_lock must be held when using this:[m
   struct proc *parent;         // Parent process[m
[1mdiff --git a/kernel/syscall.c b/kernel/syscall.c[m
[1mindex c1b3670..f362a2d 100644[m
[1m--- a/kernel/syscall.c[m
[1m+++ b/kernel/syscall.c[m
[36m@@ -104,6 +104,9 @@[m [mextern uint64 sys_unlink(void);[m
 extern uint64 sys_wait(void);[m
 extern uint64 sys_write(void);[m
 extern uint64 sys_uptime(void);[m
[32m+[m[32mextern uint64 sys_set_cpu(void);[m
[32m+[m[32mextern uint64 sys_get_cpu(void);[m
[32m+[m[32mextern uint64 sys_cpu_process_count(void);[m
 [m
 static uint64 (*syscalls[])(void) = {[m
 [SYS_fork]    sys_fork,[m
[36m@@ -127,6 +130,9 @@[m [mstatic uint64 (*syscalls[])(void) = {[m
 [SYS_link]    sys_link,[m
 [SYS_mkdir]   sys_mkdir,[m
 [SYS_close]   sys_close,[m
[32m+[m[32m[SYS_set_cpu] sys_set_cpu,[m
[32m+[m[32m[SYS_get_cpu] sys_get_cpu,[m
[32m+[m[32m[SYS_cpu_process_count] sys_cpu_process_count[m
 };[m
 [m
 void[m
[1mdiff --git a/kernel/syscall.h b/kernel/syscall.h[m
[1mindex bc5f356..316ebb4 100644[m
[1m--- a/kernel/syscall.h[m
[1m+++ b/kernel/syscall.h[m
[36m@@ -20,3 +20,6 @@[m
 #define SYS_link   19[m
 #define SYS_mkdir  20[m
 #define SYS_close  21[m
[32m+[m[32m#define SYS_set_cpu 22[m
[32m+[m[32m#define SYS_get_cpu 23[m
[32m+[m[32m#define SYS_cpu_process_count 24[m
\ No newline at end of file[m
[1mdiff --git a/kernel/sysproc.c b/kernel/sysproc.c[m
[1mindex e8bcda9..f3bcf40 100644[m
[1m--- a/kernel/sysproc.c[m
[1m+++ b/kernel/sysproc.c[m
[36m@@ -95,3 +95,28 @@[m [msys_uptime(void)[m
   release(&tickslock);[m
   return xticks;[m
 }[m
[32m+[m
[32m+[m[32muint64[m
[32m+[m[32msys_get_cpu(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return get_cpu();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32muint64[m
[32m+[m[32msys_cpu_process_count(void)[m
[32m+[m[32m{[m
[32m+[m[32m  int cpu_num;[m
[32m+[m[32m  if(argint(0, &cpu_num) < 0)[m
[32m+[m[32m    return -1;[m
[32m+[m[32m  return cpu_process_count(cpu_num);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32muint64[m
[32m+[m[32msys_set_cpu(void)[m
[32m+[m[32m{[m
[32m+[m[32m  int cpu_num;[m
[32m+[m
[32m+[m[32m  if(argint(0, &cpu_num) < 0)[m
[32m+[m[32m    return -1;[m
[32m+[m[32m  return set_cpu(cpu_num);[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/user/user.h b/user/user.h[m
[1mindex b71ecda..f316977 100644[m
[1m--- a/user/user.h[m
[1m+++ b/user/user.h[m
[36m@@ -23,6 +23,9 @@[m [mint getpid(void);[m
 char* sbrk(int);[m
 int sleep(int);[m
 int uptime(void);[m
[32m+[m[32mint set_cpu(int);[m
[32m+[m[32mint get_cpu();[m
[32m+[m[32mint cpu_process_count(int);[m
 [m
 // ulib.c[m
 int stat(const char*, struct stat*);[m
[1mdiff --git a/user/usertests.c b/user/usertests.c[m
[1mindex 0fe7371..35f97b2 100644[m
[1m--- a/user/usertests.c[m
[1m+++ b/user/usertests.c[m
[36m@@ -393,7 +393,7 @@[m [mtruncate3(char *s)[m
     }[m
     exit(0);[m
   }[m
[31m-[m
[32m+[m[32m  printf("here1");[m
   for(int i = 0; i < 150; i++){[m
     int fd = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);[m
     if(fd < 0){[m
[36m@@ -407,7 +407,7 @@[m [mtruncate3(char *s)[m
     }[m
     close(fd);[m
   }[m
[31m-[m
[32m+[m[32m  printf("here2");[m
   wait(&xstatus);[m
   unlink("truncfile");[m
   exit(xstatus);[m
[36m@@ -2233,6 +2233,7 @@[m [mvoid[m
 MAXVAplus(char *s)[m
 {[m
   volatile uint64 a = MAXVA;[m
[32m+[m[32m  printf("%d\n", a);[m
   for( ; a != 0; a <<= 1){[m
     int pid;[m
     pid = fork();[m
[36m@@ -2818,8 +2819,8 @@[m [mmain(int argc, char *argv[])[m
     void (*f)(char *);[m
     char *s;[m
   } tests[] = {[m
[31m-    {MAXVAplus, "MAXVAplus"},[m
[31m-    {manywrites, "manywrites"},[m
[32m+[m[32m    {MAXVAplus, "MAXVAplus"},  //bad vibes[m
[32m+[m[32m    {manywrites, "manywrites"},  //never ended on ON[m
     {execout, "execout"},[m
     {copyin, "copyin"},[m
     {copyout, "copyout"},[m
[36m@@ -2833,12 +2834,12 @@[m [mmain(int argc, char *argv[])[m
     {reparent2, "reparent2"},[m
     {pgbug, "pgbug" },[m
     {sbrkbugs, "sbrkbugs" },[m
[31m-    // {badwrite, "badwrite" },[m
[32m+[m[32m    // {badwrite, "badwrite" },        //wasnt activated not by us[m
     {badarg, "badarg" },[m
     {reparent, "reparent" },[m
     {twochildren, "twochildren"},[m
     {forkfork, "forkfork"},[m
[31m-    {forkforkfork, "forkforkfork"},[m
[32m+[m[32m    {forkforkfork, "forkforkfork"},    //failed on OFF[m
     {argptest, "argptest"},[m
     {createdelete, "createdelete"},[m
     {linkunlink, "linkunlink"},[m
[36m@@ -2863,7 +2864,7 @@[m [mmain(int argc, char *argv[])[m
     {validatetest, "validatetest"},[m
     {stacktest, "stacktest"},[m
     {opentest, "opentest"},[m
[31m-    {writetest, "writetest"},[m
[32m+[m[32m    {writetest, "writetest"},  //stuck never ended on OFF as well[m
     {writebig, "writebig"},[m
     {createtest, "createtest"},[m
     {openiputtest, "openiput"},[m
[1mdiff --git a/user/usys.pl b/user/usys.pl[m
[1mindex 01e426e..1dea5cc 100755[m
[1m--- a/user/usys.pl[m
[1m+++ b/user/usys.pl[m
[36m@@ -36,3 +36,6 @@[m [mentry("getpid");[m
 entry("sbrk");[m
 entry("sleep");[m
 entry("uptime");[m
[32m+[m[32mentry("set_cpu");[m
[32m+[m[32mentry("get_cpu");[m
[32m+[m[32mentry("cpu_process_count");[m
