[1mdiff --git a/Makefile b/Makefile[m
[1mindex 328f9c6..874b648 100644[m
[1m--- a/Makefile[m
[1m+++ b/Makefile[m
[36m@@ -132,6 +132,7 @@[m [mUPROGS=\[m
 	$U/_grind\[m
 	$U/_wc\[m
 	$U/_zombie\[m
[32m+[m	[32m$U/_sanity_check\[m
 [m
 fs.img: mkfs/mkfs README $(UPROGS)[m
 	mkfs/mkfs fs.img README $(UPROGS)[m
[1mdiff --git a/kernel/defs.h b/kernel/defs.h[m
[1mindex 3564db4..8a5567a 100644[m
[1m--- a/kernel/defs.h[m
[1m+++ b/kernel/defs.h[m
[36m@@ -53,6 +53,9 @@[m [mint             readi(struct inode*, int, uint64, uint, uint);[m
 void            stati(struct inode*, struct stat*);[m
 int             writei(struct inode*, int, uint64, uint, uint);[m
 void            itrunc(struct inode*);[m
[32m+[m[32mstruct inode*   dereference_link(struct inode*, int*);[m
[32m+[m[32mint             sym_link(const char*, const char*);[m
[32m+[m[32mint             read_link(const char*, char*, int);[m
 [m
 // ramdisk.c[m
 void            ramdiskinit(void);[m
[1mdiff --git a/kernel/exec.c b/kernel/exec.c[m
[1mindex d62d29d..b28fff3 100644[m
[1m--- a/kernel/exec.c[m
[1m+++ b/kernel/exec.c[m
[36m@@ -20,6 +20,7 @@[m [mexec(char *path, char **argv)[m
   struct proghdr ph;[m
   pagetable_t pagetable = 0, oldpagetable;[m
   struct proc *p = myproc();[m
[32m+[m[32m  int derederence_count = MAXDEREFERENCE;[m
 [m
   begin_op();[m
 [m
[36m@@ -29,6 +30,11 @@[m [mexec(char *path, char **argv)[m
   }[m
   ilock(ip);[m
 [m
[32m+[m[32m  if((ip = dereference_link(ip, &derederence_count)) == 0){   //not sure if supposed to be after the saniy check of dir or not[m
[32m+[m[32m      end_op();[m
[32m+[m[32m      panic("failed to dereference link on exec\n");[m
[32m+[m[32m    }[m
[32m+[m
   // Check ELF header[m
   if(readi(ip, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf))[m
     goto bad;[m
[1mdiff --git a/kernel/fcntl.h b/kernel/fcntl.h[m
[1mindex 44861b9..e1c6190 100644[m
[1m--- a/kernel/fcntl.h[m
[1m+++ b/kernel/fcntl.h[m
[36m@@ -3,3 +3,4 @@[m
 #define O_RDWR    0x002[m
 #define O_CREATE  0x200[m
 #define O_TRUNC   0x400[m
[32m+[m[32m#define O_IGNORE_SYMLINK 0x800[m
[1mdiff --git a/kernel/file.h b/kernel/file.h[m
[1mindex b076d1d..5c4eb3a 100644[m
[1m--- a/kernel/file.h[m
[1m+++ b/kernel/file.h[m
[36m@@ -26,7 +26,7 @@[m [mstruct inode {[m
   short minor;[m
   short nlink;[m
   uint size;[m
[31m-  uint addrs[NDIRECT+1];[m
[32m+[m[32m  uint addrs[NDIRECT+2];[m
 };[m
 [m
 // map major device number to device functions.[m
[1mdiff --git a/kernel/fs.c b/kernel/fs.c[m
[1mindex 40c9bd4..c115a59 100644[m
[1m--- a/kernel/fs.c[m
[1m+++ b/kernel/fs.c[m
[36m@@ -397,6 +397,38 @@[m [mbmap(struct inode *ip, uint bn)[m
       a[bn] = addr = balloc(ip->dev);[m
       log_write(bp);[m
     }[m
[32m+[m
[32m+[m[32m    brelse(bp);[m
[32m+[m[32m    return addr;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  bn -= NINDIRECT;[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m  if(bn < DINDIRECT){[m
[32m+[m[32m    int first = bn / NINDIRECT;[m
[32m+[m[32m    int second = bn % NINDIRECT;[m
[32m+[m[32m    if((addr = ip->addrs[NDIRECT+1]) == 0)[m
[32m+[m[32m      ip->addrs[NDIRECT+1] = addr = balloc(ip->dev);[m
[32m+[m[32m    bp = bread(ip->dev, addr);[m
[32m+[m[32m    a = (uint*)bp->data;[m
[32m+[m[32m    // if((addr = a[bn]) == 0){[m
[32m+[m[32m    //   a[bn] = addr = balloc(ip->dev);[m
[32m+[m[32m    //   log_write(bp);[m
[32m+[m[32m    // }[m
[32m+[m[32m    if ((addr = a[first]) == 0){[m
[32m+[m[32m      a[first] = addr = balloc(ip->dev);[m
[32m+[m[32m      log_write(bp);[m
[32m+[m[32m    }[m
[32m+[m[32m    brelse(bp);[m
[32m+[m
[32m+[m[32m    bp = bread(ip->dev, addr);[m
[32m+[m[32m    a = (uint*)bp->data;[m
[32m+[m[32m    if((addr = a[second]) == 0){[m
[32m+[m[32m      a[second] = addr = balloc(ip->dev);[m
[32m+[m[32m      log_write(bp);[m
[32m+[m[32m    }[m
     brelse(bp);[m
     return addr;[m
   }[m
[36m@@ -432,6 +464,30 @@[m [mitrunc(struct inode *ip)[m
     ip->addrs[NDIRECT] = 0;[m
   }[m
 [m
[32m+[m[32m  // free the double indirect inodes[m
[32m+[m[32m  if(ip->addrs[NDIRECT + 1]){[m
[32m+[m[32m    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);[m
[32m+[m[32m    a = (uint*)bp->data;[m
[32m+[m[32m    struct buf *bp_inside;[m
[32m+[m[32m    uint* b;[m
[32m+[m[32m    for(i = 0; i < NINDIRECT; i++){[m
[32m+[m[32m      if(a[i]){[m
[32m+[m[32m        bp_inside = bread(ip->dev, a[i]);[m
[32m+[m[32m        b = (uint*)bp_inside->data;[m
[32m+[m[32m        for(j = 0; j < NINDIRECT; j++){[m
[32m+[m[32m          if(b[j])[m
[32m+[m[32m            bfree(ip->dev, b[j]);[m
[32m+[m[32m        }[m
[32m+[m[32m        brelse(bp_inside);[m
[32m+[m[32m        bfree(ip->dev, a[i]);[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    brelse(bp);[m
[32m+[m[32m    bfree(ip->dev, ip->addrs[NDIRECT + 1]);[m
[32m+[m[32m    ip->addrs[NDIRECT + 1] = 0;[m
[32m+[m[32m  }[m
[32m+[m
   ip->size = 0;[m
   iupdate(ip);[m
 }[m
[36m@@ -592,7 +648,7 @@[m [mdirlink(struct inode *dp, char *name, uint inum)[m
 //[m
 // Examples:[m
 //   skipelem("a/bb/c", name) = "bb/c", setting name = "a"[m
[31m-//   skipelem("///a//bb", name) = "bb", setting name = "a"[m
[32m+[m[32m//   skipelem("///a//bb", name) = "bb", setting name = "a"[m[41m [m
 //   skipelem("a", name) = "", setting name = "a"[m
 //   skipelem("", name) = skipelem("////", name) = 0[m
 //[m
[36m@@ -626,7 +682,7 @@[m [mskipelem(char *path, char *name)[m
 // path element into name, which must have room for DIRSIZ bytes.[m
 // Must be called inside a transaction since it calls iput().[m
 static struct inode*[m
[31m-namex(char *path, int nameiparent, char *name)[m
[32m+[m[32mnamex(char *path, int nameiparent, char *name, int ref_count)[m
 {[m
   struct inode *ip, *next;[m
 [m
[36m@@ -637,6 +693,11 @@[m [mnamex(char *path, int nameiparent, char *name)[m
 [m
   while((path = skipelem(path, name)) != 0){[m
     ilock(ip);[m
[32m+[m
[32m+[m[32m    if((ip = dereference_link(ip, &ref_count)) == 0){[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    }[m
[32m+[m
     if(ip->type != T_DIR){[m
       iunlockput(ip);[m
       return 0;[m
[36m@@ -664,11 +725,152 @@[m [mstruct inode*[m
 namei(char *path)[m
 {[m
   char name[DIRSIZ];[m
[31m-  return namex(path, 0, name);[m
[32m+[m[32m  return namex(path, 0, name, MAXDEREFERENCE);[m
 }[m
 [m
 struct inode*[m
 nameiparent(char *path, char *name)[m
 {[m
[31m-  return namex(path, 1, name);[m
[32m+[m[32m  return namex(path, 1, name, MAXDEREFERENCE);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint[m
[32m+[m[32mread_link(const char* path_name, char* buff, int buf_size){[m
[32m+[m[32m  struct inode *ip;[m
[32m+[m
[32m+[m[32m  begin_op();[m
[32m+[m
[32m+[m[32m  if((ip = namei((char*)path_name)) == 0){[m
[32m+[m[32m    end_op();[m
[32m+[m[32m    return -1;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  ilock(ip);[m
[32m+[m
[32m+[m[32m  if(ip->type != T_SYMBOLIC){[m
[32m+[m[32m    panic("trying to read a symbolic link which is not synbolic");[m[41m  [m
[32m+[m[32m    iunlock(ip);  //iunlockput???[m
[32m+[m[32m    end_op();[m
[32m+[m[32m    return -1;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m
[32m+[m[32m  if(readi(ip, 1, (uint64)buff, 0, buf_size) > buf_size){[m
[32m+[m[32m    iunlockput(ip);[m
[32m+[m[32m    end_op();[m
[32m+[m[32m    return -1;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  iunlockput(ip);[m
[32m+[m[32m  end_op(); //do Ineed to?[m
[32m+[m[32m  return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic struct inode*[m
[32m+[m[32mcreate(char *path, short type, short major, short minor)[m
[32m+[m[32m{[m
[32m+[m[32m  struct inode *ip, *dp;[m
[32m+[m[32m  char name[DIRSIZ];[m
[32m+[m
[32m+[m[32m  if((dp = nameiparent(path, name)) == 0)[m
[32m+[m[32m    return 0;[m
[32m+[m
[32m+[m[32m  ilock(dp);[m
[32m+[m
[32m+[m[32m  if((ip = dirlookup(dp, name, 0)) != 0){[m
[32m+[m[32m    iunlockput(dp);[m
[32m+[m[32m    ilock(ip);[m
[32m+[m[32m    if(type == T_FILE && (ip->type == T_FILE || ip->type == T_DEVICE))[m
[32m+[m[32m      return ip;[m
[32m+[m[32m    iunlockput(ip);[m
[32m+[m[32m    return 0;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  if((ip = ialloc(dp->dev, type)) == 0)[m
[32m+[m[32m    panic("create: ialloc");[m
[32m+[m
[32m+[m[32m  ilock(ip);[m
[32m+[m[32m  ip->major = major;[m
[32m+[m[32m  ip->minor = minor;[m
[32m+[m[32m  ip->nlink = 1;[m
[32m+[m[32m  iupdate(ip);[m
[32m+[m
[32m+[m
[32m+[m[32m  if(type == T_DIR){  // Create . and .. entries.[m
[32m+[m[32m    dp->nlink++;  // for ".."[m
[32m+[m[32m    iupdate(dp);[m
[32m+[m[32m    // No ip->nlink++ for ".": avoid cyclic ref count.[m
[32m+[m[32m    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)[m
[32m+[m[32m      panic("create dots");[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  if(dirlink(dp, name, ip->inum) < 0)[m
[32m+[m[32m    panic("create: dirlink");[m
[32m+[m
[32m+[m[32m  iunlockput(dp);[m
[32m+[m
[32m+[m[32m  return ip;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32mstruct inode*[m
[32m+[m[32mdereference_link(struct inode* ip, int* ref_count)[m
[32m+[m[32m{[m
[32m+[m[32m  char buff[MAXPATH];[m
[32m+[m[32m  // int len;[m
[32m+[m[32m  char name[DIRSIZ];[m
[32m+[m[32m  while(ip->type == T_SYMBOLIC){[m
[32m+[m[32m    *ref_count = *ref_count-1;[m
[32m+[m[32m    if(*ref_count==0){[m
[32m+[m[32m      iunlock(ip);[m
[32m+[m[32m      return 0;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // if(readi(ip, 0, (uint64)&len, 0, sizeof(int)) != sizeof(int)){[m
[32m+[m[32m    //   return 0;[m
[32m+[m[32m    //   iunlock(ip);[m
[32m+[m[32m    // }[m
[32m+[m
[32m+[m[32m    if (readi(ip, 0, (uint64)buff, 0, MAXPATH) > MAXPATH){[m
[32m+[m[32m      return 0;[m
[32m+[m[32m      iunlock(ip);[m
[32m+[m[32m    }[m
[32m+[m[32m    iunlockput(ip);[m
[32m+[m[32m    ip = namex(buff, 0, name, *ref_count);[m
[32m+[m[32m    ilock(ip);[m
[32m+[m[32m  }[m
[32m+[m[32m  return ip;[m
 }[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mint[m
[32m+[m[32msym_link(const char* oldpath, const char* newpath){[m
[32m+[m[32m  struct inode *ip;[m
[32m+[m[32m  int old_length = strlen(oldpath)+1;[m
[32m+[m
[32m+[m[32m  begin_op();[m
[32m+[m
[32m+[m[32m  ip = create((char*)newpath, T_SYMBOLIC, 0, 0);[m
[32m+[m[32m  if(ip == 0){    //not sure if this is because the path exists[m
[32m+[m[32m    end_op();[m
[32m+[m[32m    return -1;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  // if(writei(ip, 0, (uint64)&old_length, 0, sizeof(int)) != sizeof(int)){[m
[32m+[m[32m  //   end_op();[m
[32m+[m[32m  //   return -1;[m
[32m+[m[32m  // }[m
[32m+[m
[32m+[m[32m  if(writei(ip, 0, (uint64)oldpath, 0, old_length) != old_length){[m
[32m+[m[32m    end_op();[m
[32m+[m[32m    return -1;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  iupdate(ip);[m
[32m+[m[32m  iunlockput(ip);[m
[32m+[m
[32m+[m[32m  end_op();[m
[32m+[m[32m  return 0;[m
[32m+[m[32m}[m
[41m+[m
[1mdiff --git a/kernel/fs.h b/kernel/fs.h[m
[1mindex 139dcc9..1865dee 100644[m
[1m--- a/kernel/fs.h[m
[1m+++ b/kernel/fs.h[m
[36m@@ -26,7 +26,8 @@[m [mstruct superblock {[m
 [m
 #define NDIRECT 12[m
 #define NINDIRECT (BSIZE / sizeof(uint))[m
[31m-#define MAXFILE (NDIRECT + NINDIRECT)[m
[32m+[m[32m#define DINDIRECT (NINDIRECT * NINDIRECT)[m
[32m+[m[32m#define MAXFILE (NDIRECT + NINDIRECT + DINDIRECT)[m
 [m
 // On-disk inode structure[m
 struct dinode {[m
[36m@@ -35,7 +36,10 @@[m [mstruct dinode {[m
   short minor;          // Minor device number (T_DEVICE only)[m
   short nlink;          // Number of links to inode in file system[m
   uint size;            // Size of file (bytes)[m
[31m-  uint addrs[NDIRECT+1];   // Data block addresses[m
[32m+[m
[32m+[m[32m  // changed, added +2 for the double indirect[m
[32m+[m[32m  uint addrs[NDIRECT+2];   // Data block addresses[m
[32m+[m[32m  char padding[128 - 12 - 14*4];[m
 };[m
 [m
 // Inodes per block.[m
[1mdiff --git a/kernel/param.h b/kernel/param.h[m
[1mindex b5fdcb2..699db13 100644[m
[1m--- a/kernel/param.h[m
[1m+++ b/kernel/param.h[m
[36m@@ -9,5 +9,6 @@[m
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes[m
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log[m
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache[m
[31m-#define FSSIZE       1000  // size of file system in blocks[m
[32m+[m[32m#define FSSIZE       (1 << 17)  // size of file system in blocks[m
 #define MAXPATH      128   // maximum file path name[m
[32m+[m[32m#define MAXDEREFERENCE 31   //maximum number of softlink dereferences[m
[1mdiff --git a/kernel/stat.h b/kernel/stat.h[m
[1mindex 19543af..b3fcec8 100644[m
[1m--- a/kernel/stat.h[m
[1m+++ b/kernel/stat.h[m
[36m@@ -1,6 +1,7 @@[m
 #define T_DIR     1   // Directory[m
 #define T_FILE    2   // File[m
 #define T_DEVICE  3   // Device[m
[32m+[m[32m#define T_SYMBOLIC 4  //Symbolic link[m
 [m
 struct stat {[m
   int dev;     // File system's disk device[m
[1mdiff --git a/kernel/syscall.c b/kernel/syscall.c[m
[1mindex c1b3670..2be2b71 100644[m
[1m--- a/kernel/syscall.c[m
[1m+++ b/kernel/syscall.c[m
[36m@@ -104,6 +104,8 @@[m [mextern uint64 sys_unlink(void);[m
 extern uint64 sys_wait(void);[m
 extern uint64 sys_write(void);[m
 extern uint64 sys_uptime(void);[m
[32m+[m[32mextern uint64 sys_symlink(void);[m
[32m+[m[32mextern uint64 sys_readlink(void);[m
 [m
 static uint64 (*syscalls[])(void) = {[m
 [SYS_fork]    sys_fork,[m
[36m@@ -127,6 +129,8 @@[m [mstatic uint64 (*syscalls[])(void) = {[m
 [SYS_link]    sys_link,[m
 [SYS_mkdir]   sys_mkdir,[m
 [SYS_close]   sys_close,[m
[32m+[m[32m[SYS_symlink] sys_symlink,[m
[32m+[m[32m[SYS_readlink] sys_readlink,[m
 };[m
 [m
 void[m
[1mdiff --git a/kernel/syscall.h b/kernel/syscall.h[m
[1mindex bc5f356..e2428f1 100644[m
[1m--- a/kernel/syscall.h[m
[1m+++ b/kernel/syscall.h[m
[36m@@ -20,3 +20,5 @@[m
 #define SYS_link   19[m
 #define SYS_mkdir  20[m
 #define SYS_close  21[m
[32m+[m[32m#define SYS_symlink 22[m
[32m+[m[32m#define SYS_readlink 23[m
[1mdiff --git a/kernel/sysfile.c b/kernel/sysfile.c[m
[1mindex 5dc453b..38676f5 100644[m
[1m--- a/kernel/sysfile.c[m
[1m+++ b/kernel/sysfile.c[m
[36m@@ -16,6 +16,7 @@[m
 #include "file.h"[m
 #include "fcntl.h"[m
 [m
[32m+[m
 // Fetch the nth word-sized system call argument as a file descriptor[m
 // and return both the descriptor and the corresponding struct file.[m
 static int[m
[36m@@ -267,6 +268,9 @@[m [mcreate(char *path, short type, short major, short minor)[m
   ip->nlink = 1;[m
   iupdate(ip);[m
 [m
[32m+[m[32m  //not sure - chdir support[m
[32m+[m
[32m+[m
   if(type == T_DIR){  // Create . and .. entries.[m
     dp->nlink++;  // for ".."[m
     iupdate(dp);[m
[36m@@ -291,6 +295,7 @@[m [msys_open(void)[m
   struct file *f;[m
   struct inode *ip;[m
   int n;[m
[32m+[m[32m  int derederence_count = MAXDEREFERENCE;[m
 [m
   if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)[m
     return -1;[m
[36m@@ -309,7 +314,16 @@[m [msys_open(void)[m
       return -1;[m
     }[m
     ilock(ip);[m
[31m-    if(ip->type == T_DIR && omode != O_RDONLY){[m
[32m+[m
[32m+[m[32m    if(!(O_IGNORE_SYMLINK & omode)){[m
[32m+[m[32m      if((ip = dereference_link(ip, &derederence_count)) == 0){   //not sure if supposed to be after the saniy check of dir or not[m
[32m+[m[32m        end_op();[m
[32m+[m[32m        panic("failed to dereference link on open\n");[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[41m [m
[32m+[m[32m    if(ip->type == T_DIR && !((omode == O_RDONLY) | (omode == O_IGNORE_SYMLINK))){[m
       iunlockput(ip);[m
       end_op();[m
       return -1;[m
[36m@@ -393,6 +407,7 @@[m [msys_chdir(void)[m
   char path[MAXPATH];[m
   struct inode *ip;[m
   struct proc *p = myproc();[m
[32m+[m[32m  int derederence_count = MAXDEREFERENCE;[m
   [m
   begin_op();[m
   if(argstr(0, path, MAXPATH) < 0 || (ip = namei(path)) == 0){[m
[36m@@ -400,6 +415,13 @@[m [msys_chdir(void)[m
     return -1;[m
   }[m
   ilock(ip);[m
[32m+[m
[32m+[m
[32m+[m[32m  if((ip = dereference_link(ip, &derederence_count)) == 0){   //not sure if supposed to be after the saniy check of dir or not[m
[32m+[m[32m      end_op();[m
[32m+[m[32m      panic("failed to dereference link on chdir\n");[m
[32m+[m[32m  }[m
[32m+[m
   if(ip->type != T_DIR){[m
     iunlockput(ip);[m
     end_op();[m
[36m@@ -484,3 +506,30 @@[m [msys_pipe(void)[m
   }[m
   return 0;[m
 }[m
[32m+[m
[32m+[m[32muint64[m
[32m+[m[32msys_symlink(void)[m
[32m+[m[32m{[m
[32m+[m[32m  char oldpath[MAXPATH];[m
[32m+[m[32m  char newpath[MAXPATH];[m
[32m+[m[32m  int old_length;[m
[32m+[m
[32m+[m[41m  [m
[32m+[m[32m  if((old_length = argstr(0, oldpath, MAXPATH)) < 0 || argstr(1, newpath, MAXPATH) < 0)[m
[32m+[m[32m    return -1;[m
[32m+[m
[32m+[m[32m  return sym_link(oldpath, newpath);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32muint64[m
[32m+[m[32msys_readlink(void)[m
[32m+[m[32m{[m
[32m+[m[32m  char path_name[MAXPATH];[m
[32m+[m[32m  uint64 buff;[m
[32m+[m[32m  int buf_size;[m
[32m+[m[32m  // argint(1, buff);[m
[32m+[m[32m  if((argstr(0, path_name, MAXPATH)) < 0 || argaddr(1, &buff) < 0 || argint(2, &buf_size) < 0)[m
[32m+[m[32m    return -1;[m
[32m+[m
[32m+[m[32m  return read_link(path_name, (char*)buff, buf_size);[m
[32m+[m[32m}[m
[1mdiff --git a/user/ln.c b/user/ln.c[m
[1mindex 1894143..5e9c273 100644[m
[1m--- a/user/ln.c[m
[1m+++ b/user/ln.c[m
[36m@@ -5,11 +5,18 @@[m
 int[m
 main(int argc, char *argv[])[m
 {[m
[31m-  if(argc != 3){[m
[31m-    fprintf(2, "Usage: ln old new\n");[m
[32m+[m[32m  char* s = "-s";[m
[32m+[m[32m  if((argc != 3 || (argc == 3 && strcmp(argv[1], s) == 0)) && (argc != 4 || (argc == 4 && strcmp(argv[1], s) != 0))){[m
[32m+[m[32m    fprintf(2, "Usage: ln old new or ln -s old new\n");[m
     exit(1);[m
   }[m
[31m-  if(link(argv[1], argv[2]) < 0)[m
[31m-    fprintf(2, "link %s %s: failed\n", argv[1], argv[2]);[m
[32m+[m[32m  if(argc == 3){[m
[32m+[m[32m    if(link(argv[1], argv[2]) < 0)[m
[32m+[m[32m      fprintf(2, "link %s %s: failed\n", argv[1], argv[2]);[m
[32m+[m[32m  } else{[m
[32m+[m[32m    if(symlink(argv[2], argv[3]) < 0){[m
[32m+[m[32m      fprintf(2, "symbolic link %s %s: failed\n", argv[2], argv[3]);[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
   exit(0);[m
 }[m
[1mdiff --git a/user/ls.c b/user/ls.c[m
[1mindex b54d951..5f7044c 100644[m
[1m--- a/user/ls.c[m
[1m+++ b/user/ls.c[m
[36m@@ -2,21 +2,31 @@[m
 #include "kernel/stat.h"[m
 #include "user/user.h"[m
 #include "kernel/fs.h"[m
[32m+[m[32m#include "kernel/param.h"[m
[32m+[m[32m#include "kernel/fcntl.h"[m
 [m
 char*[m
[31m-fmtname(char *path)[m
[32m+[m[32mfmtname(char *path, int issymbolic)[m
 {[m
   static char buf[DIRSIZ+1];[m
   char *p;[m
[31m-[m
[32m+[m[32m  char sym_name[MAXPATH];[m
[32m+[m[32m  char* arrow = " -> ";[m
[32m+[m[32m  if(issymbolic){[m
[32m+[m[32m    readlink((const char*) path, sym_name, MAXPATH);[m
[32m+[m[32m  }[m
   // Find first character after last slash.[m
   for(p=path+strlen(path); p >= path && *p != '/'; p--)[m
     ;[m
   p++;[m
[31m-[m
[32m+[m[41m  [m
   // Return blank-padded name.[m
   if(strlen(p) >= DIRSIZ)[m
     return p;[m
[32m+[m[32m  if(issymbolic){[m
[32m+[m[32m    memmove(p+strlen(p), arrow, strlen(arrow));[m
[32m+[m[32m    memmove(p+strlen(p), sym_name, strlen(sym_name));[m
[32m+[m[32m  }[m
   memmove(buf, p, strlen(p));[m
   memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));[m
   return buf;[m
[36m@@ -29,8 +39,9 @@[m [mls(char *path)[m
   int fd;[m
   struct dirent de;[m
   struct stat st;[m
[32m+[m[32m  char buff[MAXPATH];[m
 [m
[31m-  if((fd = open(path, 0)) < 0){[m
[32m+[m[32m  if((fd = open(path, O_IGNORE_SYMLINK)) < 0){[m
     fprintf(2, "ls: cannot open %s\n", path);[m
     return;[m
   }[m
[36m@@ -42,8 +53,14 @@[m [mls(char *path)[m
   }[m
 [m
   switch(st.type){[m
[32m+[m[32m  case T_SYMBOLIC:[m
[32m+[m[32m    // printf("poop\n");[m
[32m+[m[32m    // readlink(path, buff, MAXPATH);[m
[32m+[m[32m    // printf("%s\n", buff);[m
[32m+[m[32m    printf("%s -> %s %d %d %l\n", fmtname(path, 1), buff+4, st.type, st.ino, st.size);[m
[32m+[m
   case T_FILE:[m
[31m-    printf("%s %d %d %l\n", fmtname(path), st.type, st.ino, st.size);[m
[32m+[m[32m    printf("%s %d %d %l\n", fmtname(path, 0), st.type, st.ino, st.size);[m
     break;[m
 [m
   case T_DIR:[m
[36m@@ -63,7 +80,12 @@[m [mls(char *path)[m
         printf("ls: cannot stat %s\n", buf);[m
         continue;[m
       }[m
[31m-      printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);[m
[32m+[m[32m      if(st.type == T_SYMBOLIC){[m
[32m+[m[32m        readlink(buf,buff, MAXPATH);[m
[32m+[m[32m        printf("%s %d %d %d\n", fmtname(buf, 1), st.type, st.ino, st.size);[m
[32m+[m[32m      } else{[m
[32m+[m[32m        printf("%s %d %d %d\n", fmtname(buf, 0), st.type, st.ino, st.size);[m
[32m+[m[32m      }[m
     }[m
     break;[m
   }[m
[1mdiff --git a/user/ulib.c b/user/ulib.c[m
[1mindex 4775939..6322290 100644[m
[1m--- a/user/ulib.c[m
[1m+++ b/user/ulib.c[m
[36m@@ -76,7 +76,7 @@[m [mstat(const char *n, struct stat *st)[m
   int fd;[m
   int r;[m
 [m
[31m-  fd = open(n, O_RDONLY);[m
[32m+[m[32m  fd = open(n, O_RDONLY | O_IGNORE_SYMLINK);[m
   if(fd < 0)[m
     return -1;[m
   r = fstat(fd, st);[m
[1mdiff --git a/user/user.h b/user/user.h[m
[1mindex b71ecda..1c6d842 100644[m
[1m--- a/user/user.h[m
[1m+++ b/user/user.h[m
[36m@@ -23,6 +23,8 @@[m [mint getpid(void);[m
 char* sbrk(int);[m
 int sleep(int);[m
 int uptime(void);[m
[32m+[m[32mint symlink(const char*, const char*);[m
[32m+[m[32mint readlink(const char*, char*, int);[m
 [m
 // ulib.c[m
 int stat(const char*, struct stat*);[m
[1mdiff --git a/user/usys.pl b/user/usys.pl[m
[1mindex 01e426e..045a9d0 100755[m
[1m--- a/user/usys.pl[m
[1m+++ b/user/usys.pl[m
[36m@@ -36,3 +36,5 @@[m [mentry("getpid");[m
 entry("sbrk");[m
 entry("sleep");[m
 entry("uptime");[m
[32m+[m[32mentry("symlink");[m
[32m+[m[32mentry("readlink");[m
